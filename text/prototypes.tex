\chapter{Prototypes}

\section{Pigeon 9000}

\subsection{Concept}
The first prototype's name is alluding to Falcon 9 \cite{falcon9} by SpaceX \cite{spacex}, the only reusable orbital class rocket with a propulsively landing booster currently available. 

The cheapest method to model a propulsion system was determined to be the usage of compressed air. 

To circumvent the implications of the Tsiolkovsky rocket equation \cite{rocket-equation} it was decided against mounting a compressed air canister onto the actual rocket corpus and instead separating the air source and the model.
 
% Explain effects of the Tsiolkovsky rocket equation

To regulate the generated thrust a controllable valve had to be fitted between the rocket corpus and the air source. 

The focus of this first prototype was gaining experience handling thrust generated by compressed air systems. To minimize complexity, the movement of the corpus is constrained to the y-axis by a linear guide.

\begin{figure}[h]
\centering

\includegraphics[width=60mm]{sketch_00_first_concept}

\caption{Draft of the first concept on a linear guide. Flexible tubes are fitted to the left and right side of the rocket corpus. Pressurized air is directed through these tubes.}
\end{figure}

   
\subsection{Implementation}
\subsubsection{Planning}
In the first meeting the most expensive and important part was acquired, a digitally controllable valve by Festo \cite{festo-valve} capable of handling pressures of up to 8bar. Additionally options for a linear guide and the rocket corpus were discussed. Using a table and utilizing it's legs as the guide and a PE pipe as the corpus was deemed the most practical approach. 

Table leg diameters were gathered by browsing the table section of a large furniture store to compare to PE pipes available in nearby hardware stores. When suitable guides and corpora were found they were compared until a \SI{37}{\centi\meter} high side table \cite{table} with a leg diameter of \SI{25}{\milli\meter} and a pipe with \SI{27}{\milli\meter} inner diameter were picked. Additionally a special plastic glue, intended to be used to attach the pressure tubes to the rocket body, was purchased, even though the exact type of pressure tube that was going to be used was still unknown.

After the essential parts were gathered construction work began. 

\subsubsection{Basic components}
A \SI{5}{\centi\meter} segment of the pipe was cut off to form the demonstrator corpus.

\begin{figure}[h]
\centering

\includegraphics[width=70mm]{sketch_01_table_and_corpus}

\caption{Table with corpus fitted to one of it's legs. The table legs have a diameter of \SI{2,5}{\centi\meter} and a height of \SI{36}{\centi\meter}. The tube that is used as the corpus is \SI{5}{\centi\meter} high, has an inside diameter of \SI{2,7}{\centi\meter} and an outside diameter of \SI{3,2}{\centi\meter}. Therefor the clearance between guide and corpus is \SI{1}{\milli\meter}.}
\end{figure}

% Insert math here

Initial weight measurements amounted to \SI{8,13}{\gram}. High tolerances were included in the initial calculations because attaching the pressure tubes to the body was expected to double it's weight, which was later confirmed by a measurement of \SI{17,53}{\gram}.

It was assumed that a nozzle at the end of the pressure tube was needed in order to produce a sufficient amount of thrust to lift the corpus.
To validate this assumption an electronic grain scale was used. Air pressure was applied to the scale surface from a distance of \SI{1}{\centi\meter} through a generic air blow gun with a nozzle diameter of \SI{2}{\milli\meter}. With \SI{2,5}{\bar} out of \SI{8}{\bar} available pressure, the scale was maxed out at \SI{100}{\gram} which led to the realization that the amount of thrust produced by the compressor was more than enough to achieve liftoff. 


After receiving a PU pressure tube with \SI{6}{\milli\meter} outer diameter and \SI{4}{\milli\meter} inner diameter, attempts were made to attach it to the corpus with the previously purchased plastic glue which was not able to connect the parts. In the course of investigating the problem it was discovered that the unreasonably expensive glue was not meant to stick to PE, which was mentioned in the fine print of the product packaging but went unnoticed. Instead, duct tape was used as a temporary solution. 

\begin{figure}[h]
\centering

\includegraphics[height=85mm]{sketch_03_corpus}

\caption{PE pipe used as rocket corpus. Duct tape is utilized to attach two PU tubes to either side of the body.}
\end{figure}

Consulting the documentation of the Festo valve revealed the need for a \SI{24}{\volt} power source. At this point in time it was still planned to power the whole prototype off battery power, for the sake of portability. The lack of cheap and long-lasting batteries that could be combined to provide \SI{24}{\volt} led to the conclusion, that a power supply was necessary. This resulted in an online purchase of a laptop charger \cite{power-supply} with the appropriate voltage from a common online retailer.

\subsubsection{Pneumatics 101}
Connecting the PU tube to the Festo valve proved difficult because \SI{4}{\milli\meter} inner diameter is not an off-the-shelf size but instead used in industrial applications, therefor visits of every nearby hardware store with the intention of finding fitting connector parts were unsuccessful. Instead of ordering proper parts in a specialized online store, the decision was made to buy parts that were not intended for the tube diameter because long delivery times would have delayed the assembly by about a week. A crimp fitting with \SI{6}{\milli\meter} inner diameter, \SI{10}{\milli\meter}-\SI{16}{\milli\meter} regular hose clamps and \SI{11}{\milli\meter}-\SI{13}{\milli\meter} o-clip hose clamps were purchased. 

Connecting the crimp fitting to the pressure tube was successful with the help of a bunsen burner and a high amount of force. Electrical tape was wrapped around the tube to increase it's diameter in an effort to enable the clamps to fit.

The o-clip hose clamp could not be applied because it's diameter was still to large, even in it's crimped down state. The regular hose clamp fitted by over tightening it. This solution was not ideal because testing the connection revealed a high amount of pressure loss. It was therefor necessary to put up with the shipping delay and wait for the proper sized crimp fittings to arrive. A T-shaped crimp fitting was ordered in addition to regular crimp fittings and proper sized o-clip hose clamps in an effort to simplify the connection between the valve and both of the corpus tubes. Additionally the required electrical cable for the Festo valve was ordered because it too is not an off-the-shelf part and the risk generated by randomly sticking wires into the exposed ports on the valve was deemed too high.


\begin{figure}[h]
\centering

\includegraphics[width=45mm]{tube_botch}

\caption{Botched PU pressure tube fixed to an over sized crimp fitting by heating the tube ending and wrapping it in electrical tape to increase it's outer diameter. Additionally the connection is secured with an overtightened hose clamp.}
\end{figure}

The waiting period was utilized to find a fitting connector between the Festo valve and a customary compressor. This proved difficult because the connector size used by the valve is 1/8inch, which is mostly used in industrial applications. The compressor uses a more common 1/4inch connector, therefor an adapter was needed. Out of four nearby hardware stores only one carried any parts that were similar to the ones needed. These were promptly acquired and surprisingly fitted without any further issues.

\begin{figure}[h]
\centering

\includegraphics[width=85mm]{valve_assembly}

\caption{Festo valve with proper power connection. The T-shaped crimp fitting connects the valve to the pressure tubes that are attached to the corpus. The o-clip hose clamps provide additional protection against pressure loss. The compressor connector is attached to the valve via a 1/4inch to 1/8inch threaded adapter.}
\end{figure}

The delivered T-shaped crimp fitting finally enabled a successful connection between the corpus and the valve without any noticeable pressure loss.  

With most mechanical components in-place the attention was shifted to the electronic parts necessary, starting with a breadboard which was salvaged from an educational experimentation kit. 

To control the electronic valve with a microcomputer later on, it was plugged into the normal close port of a relay which allows for programmatic switching of \SI{24}{\volt} power. 

\subsubsection{Control components}
A Raspberry Pi 3 Model B \cite{raspberry-pi} was chosen as the development board because it enables high and low level programming with short iteration cycles thanks to a full-fledged underlying operating system \cite{raspbian} with networking capabilities. Manipulation of the GPIO ports is well documented, I2C and SPI are supported with kernel command line flags and example code for most sensors is available on the internet. Additionally, a Raspberry Pi did not have to be acquired because one was already available.

\begin{figure}[h]
\centering

\includegraphics[height=90mm]{raspberry-pi}

\caption{A Raspberry Pi 3 Model B}
\end{figure}

An Arduino was decided against mainly because of the slower and less convenient development experience and the current lack of Rust \cite{rust} support, which is planned to be used as the projects low level language.

Before mounting the components onto the table they were tested individually. Once the functionality of each part was validated a demo application was written in Python to assess their combined functionality by switching the relay on and off. In the first dry run without a compressed air supply the valve emitted an audible click which gave the impression of a full switch operation happening inside the component.

\subsubsection{Finalizing assembly}
After these tests where conducted all components were mounted onto the top of the table in addition to a distributor socket with the purpose of simplifying power delivery.

\begin{figure}[h]
\centering

\includegraphics[width=130mm]{sketch_04_topview}

\caption{Table construction from the top. In the bottom left corner the valve is mounted to the table with two screws, the \SI{24}{\volt} power supply is surrounded by the valve power cable. The distributor socket is fixed to the bottom right corner with double-sided tape which provides power to the valve and the Raspberry Pi 3 Model B in the upper right corner. The breadboard is connected to the Pi with a ribbon cable. The relay, which controls the valve power circuit, is attached to the breadboard with jumper cables.}
\end{figure}

To transport the compressed air to the corpus, where it is needed to produce thrust, the pressure tubes mounted to the simulated rocket body had the be routed to the valve in a way that did not cause much interference with it's flight behavior. 

In an effort to combat the stiffness of the air tubes they were suspended from the vertical middle of the table leg right next to the designated guide leg, however this did not improve the issue but worsened it instead. 

After some investigation it was discovered that the length of the dangling tubes is the main determining factor in reducing it's overall stiffness, so instead of routing the tubes from the leg beside the corpus, the upper end of the leg that is diagonal to the guide was chosen as the suspension point. This mounting position was chosen because it provides the greatest possible free hanging distance within the confines of the table.

\begin{figure}[h]
\centering

\includegraphics[width=165mm]{sketch_05_side_and_topview}

\caption{The compressed air tubes are routed directly from the valve, which is in the furthest possible position from the rocket corpus. This way about 90\% of the tube length is able to move freely and therefore minimize overall stiffness.}
\end{figure}


\subsection{Manual control}
With the installation of all components completed, a first test run with the intention of verifying the behavior of the valve under real conditions was conducted, this time with an electrical compressor connected to it. Instead of controlling it with a computer program, the power cable was manually plugged into the breadboard for short periods of time, with the expectation of successful on/off switches of the valve, however that was not the case. Instead air was flowing through even though the valve was supposed to be in a closed state. 

Reviewing the documentation revealed that the minimum amount of pressure required for full operation is \SI{2,5}{\bar}. This was not achievable because the valve would have to cut off the air-flow to allow the compressor to build up pressure.

It was discovered that the compressed air tube coupler contains a cut-off mechanism that prevents air from escaping while it is not connected. This fact was taken advantage of to provide a temporary solution, which entails connecting the air tube only after the threshold is reached. Attaching a cut-off connector between the compressor and the valve was considered as a fix later down the road.


\subsection{Basic software control}
NASA's Jet Propulsion Laboratory \cite{jpl} has published a rigorous rule set \cite{jpl-rules} regarding programming conventions of mission critical code. These rules primarily apply to code written in the C programming language and specifically address memory safety issues regarding shared data and resource ownership, that can result in indeterministic behavior. 

These concerns are also relevant in the information security community, which led to the creation of compiler languages that can guarantee additional safety at compile time. 

Rust \cite{rust} is one of these languages and was chosen as the foundation of core software components for which reliability and stability is key because the restrictions it imposes on the programmer are very similar to the conventions set up by the NASA Jet Propulsion Laboratory.

\subsection{Controlling the valve}
Experimentation with test programs revealed that a full on/off cycle of the valve, taking the latency introduced by the relay into account, takes at least \SI{70}{\milli\second} according to the their respective documentations. 
\begin{align*}
    \SI{19}{\milli\second} + \SI{10}{\milli\second} &=\SI{29}{\milli\second} && \text{Valve switch on time} + \text{Relay switch on time} \\
    \SI{36}{\milli\second} + \SI{5}{\milli\second}  &=\SI{41}{\milli\second} && \text{Valve switch off time} + \text{Relay switch off time}\\
    \SI{29}{\milli\second} + \SI{41}{\milli\second} &=\SI{70}{\milli\second} 
\end{align*}

A simple valve control program was written to verify this calculation. Values as low as \SI{40}{\milli\second} still resulted in a full on/off switch but were ultimately decided against because the chance of them wearing out the hardware after lengthy continuous operation was deemed to high.

After these tests were conducted, a low latency way of interacting with the GPIO pins on the Raspberry Pi from within Rust had to be found. A project search on GitHub revealed multiple libraries that offer this functionality. 

\begin{table}[h]
\centering
\begin{tabular}{llll}
\textbf{Library} & \textbf{Access method} & \textbf{Maintained} & \textbf{Documented} \\
cupi             & sysfs / memory access  & No                  & No                  \\
cylus            & memory access          & No                  & No                  \\
gpio-rs          & sysfs / memory access  & No                  & No                  \\
rppal            & memory access          & Yes                 & Yes                 \\
rust-sysfs-gpio  & sysfs                  & Yes                 & Yes
\end{tabular}
\caption{Rust GPIO library comparison. The access }
\end{table}

sysfs is a pseudo Linux file system that provides information about kernel subsystems, hardware devices, and device drivers in addition to the ability to configure them. It lives in userspace and can not be relied upon if timing of operations is required to be deterministic. 

rust-sysfs-gpio was selected as the GPIO library because of it's widespread usage, it's detailed documentation and a high commit frequency addressing issues reported by users. The access method was not deemed relevant at this point in time because the fact that sysfs operation timings are not deterministic was not obtained until first experiments were conducted. While timing was not an issue during these tests, the decision was made to switch to a direct memory access solution because of concerns regarding future situations in which precise operation would be required. 

rppal was then chosen as the GPIO read/write solution because it was the only other well documented library that was still being maintained.

% das timing damit nicht nachvollziehbar ist, nicht gewusst. information erfahren, erwartet, dass es irgendwann probleme macht.

% sysfs is a pseudo file system provided by the Linux kernel that exports information about various kernel subsystems, hardware devices, and associated device drivers from the kernel's device model to user space through virtual files.[1] In addition to providing information about various devices and kernel subsystems, exported virtual files are also used for their configuring.

% rust-sysfs-gpio 

% rust-sysfs-gpio \cite{rust-sysfs-gpio} was chosen because of it was still being maintained and was reasonably popular.  

% sysfs latenz nicht berechenbar

% raspberry pi spezifische memory writes

% statt selbst zu implementieren: rppal




\subsection{Advanced software control}
Mission Control like facilities have the ability to correct the state of a rocket during flight by communicating with core components over predefined protocols. To allow for fast experimentation it was determined that this approach would be adopted for the first prototype.

A client/server architecture, networked over the Transmission Control Protocol, was chosen to accomplish this design goal because the hardware setup guarantees that a stable Ethernet connection is present at all times. Additionally, client software can also be executed on the same microcomputer that the server is running on.

The server is modeled after the Unix daemon concept and is therefor named pigeond. It is implemented in Rust. The client is referred to as controller and can be written in any programming language that supports sockets, however Python is used exclusively because it's robust standard library that allows for quick iteration and experimentation.

\begin{figure}[h]
\centering

\includegraphics[width=80mm]{controller_pushes_state_to_pigeond}

\caption{A controller transmitting a state to the daemon. A state contains all necessary instructions for operation.}
\end{figure}

A state is a bundle of all necessary instructions required for operation. The first state version 

% protokoll: tcp über das json verschickt wird


% library in python to do so
% instead of directly sending ms a cycle time and ratio are provided

\subsection{Basic physical user interface}
% button
% linear slide

\subsection{Improved physical user interface}
% 2 * linear slide + knopf


\subsection{Autonomous software control}
% 


\section{Hummingbird 9000}

\subsection{Concept}

% 2guides 2 dimentional tilting ability

% use of onboard sencors (accelerometer, gyrometer, ultrasound distance)

\begin{figure}[h]
\centering

\includegraphics[width=165mm]{sketch_xx_second_concept}

\caption{Concept}
\end{figure}

\subsection{Implementation}