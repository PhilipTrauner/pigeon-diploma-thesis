\chapter{Pigeon 9000}
\section{Concept}
\author{Sebastian Schaffler}

The first prototype's name is alluding to Falcon 9 \cite{falcon9} by SpaceX \cite{spacex}, the only reusable orbital class rocket with a propulsively landing booster currently available. 

The cheapest method to model a propulsion system was determined to be the usage of compressed air. 

To circumvent the implications of the Tsiolkovsky rocket equation \cite{rocket-equation} it was decided against mounting a compressed air canister onto the actual rocket corpus and instead separating the air source and the model.
 
% Explain effects of the Tsiolkovsky rocket equation

To regulate the generated thrust a controllable valve had to be fitted between the rocket corpus and the air source. 

The focus of this first prototype was gaining experience handling thrust generated by compressed air systems. To minimize complexity, the movement of the corpus is constrained to the y-axis by a linear guide.

\begin{figure}[h]
\centering

\includegraphics[width=60mm]{sketch_00_first_concept}

\caption{Draft of the first concept on a linear guide. Flexible tubes are fitted to the left and right side of the rocket corpus. Pressurized air is directed through these tubes.}
\end{figure}

\section{Hardware implementation}
\author{Sebastian Schaffler}

\subsection{Planning}
In the first meeting the most expensive and important part was acquired, a digitally controllable valve by Festo \cite{festo-valve} capable of handling pressures of up to 8bar. Additionally options for a linear guide and the rocket corpus were discussed. Using a table and utilizing it's legs as the guide and a PE pipe as the corpus was deemed the most practical approach. 

Table leg diameters were gathered by browsing the table section of a large furniture store to compare to PE pipes available in nearby hardware stores. When suitable guides and corpora were found they were compared until a \SI{37}{\centi\meter} high side table \cite{table} with a leg diameter of \SI{25}{\milli\meter} and a pipe with \SI{27}{\milli\meter} inner diameter were picked. Additionally a special plastic glue, intended to be used to attach the pressure tubes to the rocket body, was purchased, even though the exact type of pressure tube that was going to be used was still unknown.

After the essential parts were gathered construction work began. 

\subsection{Basic components}
A \SI{5}{\centi\meter} segment of the pipe was cut off to form the demonstrator corpus.

\begin{figure}[h]
\centering

\includegraphics[width=70mm]{sketch_01_table_and_corpus}

\caption{Table with corpus fitted to one of it's legs. The table legs have a diameter of \SI{2,5}{\centi\meter} and a height of \SI{36}{\centi\meter}. The tube that is used as the corpus is \SI{5}{\centi\meter} high, has an inside diameter of \SI{2,7}{\centi\meter} and an outside diameter of \SI{3,2}{\centi\meter}. Therefor the clearance between guide and corpus is \SI{1}{\milli\meter}.}
\end{figure}

% Insert math here

Initial weight measurements amounted to \SI{8,13}{\gram}. High tolerances were included in the initial calculations because attaching the pressure tubes to the body was expected to double it's weight, which was later confirmed by a measurement of \SI{17,53}{\gram}.

It was assumed that a nozzle at the end of the pressure tube was needed in order to produce a sufficient amount of thrust to lift the corpus.
To validate this assumption an electronic grain scale was used. Air pressure was applied to the scale surface from a distance of \SI{1}{\centi\meter} through a generic air blow gun with a nozzle diameter of \SI{2}{\milli\meter}. With \SI{2,5}{\bar} out of \SI{8}{\bar} available pressure, the scale was maxed out at \SI{100}{\gram} which led to the realization that the amount of thrust produced by the compressor was more than enough to achieve liftoff. 


After receiving a PU pressure tube with \SI{6}{\milli\meter} outer diameter and \SI{4}{\milli\meter} inner diameter, attempts were made to attach it to the corpus with the previously purchased plastic glue which was not able to connect the parts. In the course of investigating the problem it was discovered that the unreasonably expensive glue was not meant to stick to PE, which was mentioned in the fine print of the product packaging but went unnoticed. Instead, duct tape was used as a temporary solution. 

\begin{figure}[h]
\centering

\includegraphics[height=85mm]{sketch_03_corpus}

\caption{PE pipe used as rocket corpus. Duct tape is utilized to attach two PU tubes to either side of the body.}
\end{figure}

Consulting the documentation of the Festo valve revealed the need for a \SI{24}{\volt} power source. At this point in time it was still planned to power the whole prototype off battery power, for the sake of portability. The lack of cheap and long-lasting batteries that could be combined to provide \SI{24}{\volt} led to the conclusion, that a power supply was necessary. This resulted in an online purchase of a laptop charger \cite{power-supply} with the appropriate voltage from a common online retailer.

\subsection{Pneumatics 101}
Connecting the PU tube to the Festo valve proved difficult because \SI{4}{\milli\meter} inner diameter is not an off-the-shelf size but instead used in industrial applications, therefor visits of every nearby hardware store with the intention of finding fitting connector parts were unsuccessful. Instead of ordering proper parts in a specialized online store, the decision was made to buy parts that were not intended for the tube diameter because long delivery times would have delayed the assembly by about a week. A crimp fitting with \SI{6}{\milli\meter} inner diameter, \SI{10}{\milli\meter}-\SI{16}{\milli\meter} regular hose clamps and \SI{11}{\milli\meter}-\SI{13}{\milli\meter} o-clip hose clamps were purchased. 

Connecting the crimp fitting to the pressure tube was successful with the help of a bunsen burner and a high amount of force. Electrical tape was wrapped around the tube to increase it's diameter in an effort to enable the clamps to fit.

The o-clip hose clamp could not be applied because it's diameter was still to large, even in it's crimped down state. The regular hose clamp fitted by over tightening it. This solution was not ideal because testing the connection revealed a high amount of pressure loss. It was therefor necessary to put up with the shipping delay and wait for the proper sized crimp fittings to arrive. A T-shaped crimp fitting was ordered in addition to regular crimp fittings and proper sized o-clip hose clamps in an effort to simplify the connection between the valve and both of the corpus tubes. Additionally the required electrical cable for the Festo valve was ordered because it too is not an off-the-shelf part and the risk generated by randomly sticking wires into the exposed ports on the valve was deemed too high.


\begin{figure}[h]
\centering

\includegraphics[width=45mm]{tube_botch}

\caption{Botched PU pressure tube fixed to an over sized crimp fitting by heating the tube ending and wrapping it in electrical tape to increase it's outer diameter. Additionally the connection is secured with an overtightened hose clamp.}
\end{figure}

The waiting period was utilized to find a fitting connector between the Festo valve and a customary compressor. This proved difficult because the connector size used by the valve is 1/8inch, which is mostly used in industrial applications. The compressor uses a more common 1/4inch connector, therefor an adapter was needed. Out of four nearby hardware stores only one carried any parts that were similar to the ones needed. These were promptly acquired and surprisingly fitted without any further issues.

\begin{figure}[h]
\centering

\includegraphics[width=85mm]{valve_assembly}

\caption{Festo valve with proper power connection. The T-shaped crimp fitting connects the valve to the pressure tubes that are attached to the corpus. The o-clip hose clamps provide additional protection against pressure loss. The compressor connector is attached to the valve via a 1/4inch to 1/8inch threaded adapter.}
\end{figure}

The delivered T-shaped crimp fitting finally enabled a successful connection between the corpus and the valve without any noticeable pressure loss.  

With most mechanical components in-place the attention was shifted to the electronic parts necessary, starting with a breadboard which was salvaged from an educational experimentation kit. 

To control the electronic valve with a microcomputer later on, it was plugged into the normal close port of a relay which allows for programmatic switching of \SI{24}{\volt} power. 

\subsection{Control components}
A Raspberry Pi 3 Model B \cite{raspberry-pi} was chosen as the development board because it enables high and low level programming with short iteration cycles thanks to a full-fledged underlying operating system \cite{raspbian} with networking capabilities. Manipulation of the GPIO ports is well documented, I2C and SPI are supported with kernel command line flags and example code for most sensors is available on the internet. Additionally, a Raspberry Pi did not have to be acquired because one was already available.

\begin{figure}[h]
\centering

\includegraphics[height=90mm]{raspberry-pi}

\caption{A Raspberry Pi 3 Model B}
\end{figure}

An Arduino was decided against mainly because of the slower and less convenient development experience and the current lack of Rust \cite{rust} support, which is planned to be used as the projects low level language.

Before mounting the components onto the table they were tested individually. Once the functionality of each part was validated a demo application was written in Python to assess their combined functionality by switching the relay on and off. In the first dry run without a compressed air supply the valve emitted an audible click which gave the impression of a full switch operation happening inside the component.

\subsection{Finalizing assembly}
After these tests where conducted all components were mounted onto the top of the table in addition to a distributor socket with the purpose of simplifying power delivery.

\begin{figure}[h]
\centering

\includegraphics[width=130mm]{sketch_04_topview}

\caption{Table construction from the top. In the bottom left corner the valve is mounted to the table with two screws, the \SI{24}{\volt} power supply is surrounded by the valve power cable. The distributor socket is fixed to the bottom right corner with double-sided tape which provides power to the valve and the Raspberry Pi 3 Model B in the upper right corner. The breadboard is connected to the Pi with a ribbon cable. The relay, which controls the valve power circuit, is attached to the breadboard with jumper cables.}
\end{figure}

To transport the compressed air to the corpus, where it is needed to produce thrust, the pressure tubes mounted to the simulated rocket body had the be routed to the valve in a way that did not cause much interference with it's flight behavior. 

In an effort to combat the stiffness of the air tubes they were suspended from the vertical middle of the table leg right next to the designated guide leg, however this did not improve the issue but worsened it instead. 

After some investigation it was discovered that the length of the dangling tubes is the main determining factor in reducing it's overall stiffness, so instead of routing the tubes from the leg beside the corpus, the upper end of the leg that is diagonal to the guide was chosen as the suspension point. This mounting position was chosen because it provides the greatest possible free hanging distance within the confines of the table.

\begin{figure}[h]
\centering

\includegraphics[width=165mm]{sketch_05_side_and_topview}

\caption{The compressed air tubes are routed directly from the valve, which is in the furthest possible position from the rocket corpus. This way about 90\% of the tube length is able to move freely and therefore minimize overall stiffness.}
\end{figure}


\subsection{Manual control}
With the installation of all components completed, a first test run with the intention of verifying the behavior of the valve under real conditions was conducted, this time with an electrical compressor connected to it. Instead of controlling it with a computer program, the power cable was manually plugged into the breadboard for short periods of time, with the expectation of successful on/off switches of the valve, however that was not the case. Instead air was flowing through even though the valve was supposed to be in a closed state. 

Reviewing the documentation revealed that the minimum amount of pressure required for full operation is \SI{2,5}{\bar}. This was not achievable because the valve would have to cut off the air-flow to allow the compressor to build up pressure.

It was discovered that the compressed air tube coupler contains a cut-off mechanism that prevents air from escaping while it is not connected. This fact was taken advantage of to provide a temporary solution, which entails connecting the air tube only after the threshold is reached. Attaching a cut-off connector between the compressor and the valve was considered as a fix later down the road.

\section{Hardware abstraction layer}
\author{Philip Trauner}

\subsection{Basic software control}
NASA's Jet Propulsion Laboratory \cite{jpl} has published a rigorous rule set \cite{jpl-rules} regarding programming conventions of mission critical code. These rules primarily apply to code written in the C programming language and specifically address memory safety issues regarding shared data and resource ownership, that can result in indeterministic behavior. 

These concerns are also relevant in the information security community, which led to the creation of compiler languages that can guarantee additional safety at compile time. 

Rust \cite{rust} is one of these languages and was chosen as the foundation of core software components for which reliability and stability is key because the restrictions it imposes on the programmer are very similar to the conventions set up by the NASA Jet Propulsion Laboratory.

\subsection{Controlling the valve}
Experimentation with test programs revealed that a full on/off cycle of the valve, taking the latency introduced by the relay into account, takes at least \SI{70}{\milli\second} according to the their respective documentations. 
\begin{figure}[h]
\begin{align*}
    \SI{19}{\milli\second} + \SI{10}{\milli\second} &=\SI{29}{\milli\second} && \text{Valve switch on time} + \text{Relay switch on time} \\
    \SI{36}{\milli\second} + \SI{5}{\milli\second}  &=\SI{41}{\milli\second} && \text{Valve switch off time} + \text{Relay switch off time}\\
    \SI{29}{\milli\second} + \SI{41}{\milli\second} &=\SI{70}{\milli\second} 
\end{align*}
\caption{Minimum on/off cycle time of the valve control setup.}
\end{figure}

A simple valve control program was written to verify this calculation. Values as low as \SI{40}{\milli\second} still resulted in a full on/off switch but were ultimately decided against because the chance of them wearing out the hardware after lengthy continuous operation was deemed to high.

After these tests were conducted, a low latency way of interacting with the GPIO pins on the Raspberry Pi from within Rust had to be found. A project search on GitHub revealed multiple libraries that offer this functionality. 

\begin{table}[h]
\centering
\begin{tabular}{llll}
\textbf{Library} & \textbf{Access method} & \textbf{Maintained} & \textbf{Documented} \\
cupi             & sysfs / memory access  & No                  & No                  \\
cylus            & memory access          & No                  & No                  \\
gpio-rs          & sysfs / memory access  & No                  & No                  \\
rppal            & memory access          & Yes                 & Yes                 \\
rust-sysfs-gpio  & sysfs                  & Yes                 & Yes
\end{tabular}
\caption{Rust General Purpose Input Output library comparison. Access method describes the way the library interacts with the GPIO pins. If an update has happened in the last three months the project is seen as maintained. Documentation is judged on the fact that there is text in addition to code which describes the functionality and usage of the library.}
\end{table}

sysfs is a pseudo Linux file system that provides information about kernel subsystems, hardware devices, and device drivers in addition to the ability to configure them. It lives in userspace and can not be relied upon if timing of operations is required to be deterministic. 

rust-sysfs-gpio \cite{rust-sysfs-gpio} was selected as the GPIO library because of it's widespread usage, it's detailed documentation and a high commit frequency addressing issues reported by users. The access method was not deemed relevant at this point in time because the fact that sysfs operation timings are not deterministic was not known until first experiments were conducted. While timing was not an issue during these tests, the decision was made to switch to a direct memory access solution because of concerns regarding future situations in which precise operation would be required. 

rppal \cite{rppal} was then chosen as the GPIO read/write solution because it was the only other well documented library that was still being maintained and uses direct memory writes to access the pins.


\subsection{Advanced software control}
Mission Control like facilities have the ability to correct the state of a rocket during flight by communicating with core components over predefined protocols. To allow for fast experimentation it was determined that this approach would be adopted for the first prototype.

A client/server architecture, networked over the Transmission Control Protocol, was chosen to accomplish this design goal because the hardware setup guarantees that a stable Ethernet connection is present at all times. Additionally, client software can also be executed on the same microcomputer that the server is running on.

The server is modeled after the Unix daemon concept and is therefor named pigeond. It is implemented in Rust. The client is referred to as controller and can be written in any programming language that supports sockets, however Python is used exclusively because it's robust standard library allows for quick iteration and experimentation.

The thrust generated by the valve can be controlled by sending a state to the daemon. A state contains the "operation time" and the "release time", which are time-spans defined in milliseconds. These values are used to perform pulse-width modulation on the valve. PWM is handled in software instead of utilizing the hardware PWM ports on the Raspberry Pi 3 Model B because those can only be configured over sysfs, which does not guarantee deterministic timing. Additionally, a power flag is present which indicates if the valve should be controlled at all. States are formatted in JSON \cite{json} because of it's broad availability across many programming languages. It is represented as human readable text instead of binary messages, which is useful for debugging purposes. 

\begin{figure}[h]
\centering

\includegraphics[width=155mm]{controller_pushes_state_to_pigeond}

\caption{A controller transmitting a state to the daemon. A state contains all necessary instructions for operation. "operation time" and "release time" are time-spans defined in milliseconds, power indicates if the valve should be controlled.}
\end{figure}

The daemon uses serde \cite{serde} to deserialize JSON to Rust structs because it's the most widely used solution available.

\section{Physical user interface}
\author{Sebastian Schaffler}

To test the daemon/controller approach dictated by the software architecture it was decided to model the physical user interface as a controller.

\subsection{Basic}
Instead of directly approaching autonomous rocket control it was decided to experiment with physical user interfaces first. This approach was chosen to test the practicality of the software design and to provide a version that can be used for demonstrations with human interaction. 

A rotary encoder \cite{rotary-encoder} combined with a button was intended as the physical interface of this prototype version because it did not require an analog to digital converter, which would have had to be acquired. After some experimentation with the component it began emitting nonsensical values. This interpreted as a component failure. 

A linear slide was then chosen to directly control the thrust generated by the valve. To determine the slide position an analog to digital converter was now necessary. A MCP3008 \cite{mcp3008} was chosen because a library \cite{mcp3008-library} to interact with it's 8 input channels was already available . 

To obtain a millisecond value from the linear slide it's position is converted to a percentage based against the full slide length and then multiplied by a constant timespan of \SI{100}{\milli\second}. The button is used to alternate between "operation time" and "release time" mode. 

This concept worked but constantly switching between modes to changes the times in proportion to each other was deemed not user friendly, instead the mode switching idea was reused to modify the previously constant time, referred to as "cycle time", and a proportional ratio between "operation time" and "release time" called "operation ratio".

\begin{figure}[h]
\begin{align*}
    ot &=ct * or && \text{operation time} \\
    rt &=ct * (1 - or) && \text{release time} \\ \\
    ct &= \text{cycle time} \\
    or &= \text{operation ratio}
\end{align*}
\caption{"operation time" and "release time" calculation. "cycle time" is the timespan in which a full on/off switch cycle takes place. "operation ratio" is a percentage describing the proportion "operation time" and "release time" in the specified "cycle time".}
\end{figure}

This concept was originally developed for the rotary encoder and transferred over to the slide, which brought some issues with it. The physical properties of the linear slide don't allow setting two distinct values at the same time. This is why the button was introduced, however mode switching would led to an immediate value override of the current mode with the value of the previous mode.

\begin{figure}[h]
\centering

\includegraphics[height=60mm]{sketch_xx_button_and_slide}

\caption{The basic physical user interface consisting of a button and a linear slide. The button is utilized to switch between "cycle time" and "operation ratio". The slide is used to modify the value of the selected mode.}
\end{figure}

\subsection{Improved}
To combat the issues of the basic physical user interface it was decided to introduce a second linear slide, which was not available at the time the basic version was implemented, to enable simultaneous adjustment of "cycle time" and "operation ratio". The button was reused to toggle valve power on and off.

A Python 3 library was written to simplify working and transmission of states after it became apparent that the same code was repeated several times. It provides a representation of states as objects which can be sent to the daemon without any knowledge of the underlying protocol. 

Hovering the corpus at a specific point along the table leg was not only possible but reproducible with this approach.   

\begin{figure}[h]
\centering

\includegraphics[height=60mm]{sketch_xx_button_and_two_slides}

\caption{The improved physical user interface consisting of a button and two linear slides. The button is toggle the thrust. The left slide is used to modify "operation ratio" and the right one to manipulate "cycle time".}
\end{figure}

\section{Autonomous software control}
\author{Philip Trauner}

After the manual solution to hover control showed promise, work on an automatic version began. Initially it was planned to utilize a pressure sensor to calculate the required thrust based on the available pressure. This idea had to be discarded because the cost of a customary pressure sensor was deemed too high at this stage in development, instead a pair of regular top-hats, which are infrared reflection sensors, were used as a light barrier to get started. The A/D converter previously acquired for the basic physical user interface was utilized to obtain readings from the sensors.

A hardware modification was necessary for the corpus to be detectable by the infrared sensors because it did not create a significant enough value spike to reliably determine if it had passed by the top-hats.
A piece of white paper was therefor attached to the side of the corpus facing the sensors. This resulted in a observable value rise and solved the detection issue.

Instead of calculating "operation time" and "release time" in the controller applications it was decided to move this computation into the daemon because direct timespan manipulation was not utilized. "operation time" and "release time" were therefor replaced by "cycle time" and "operation ratio".

\begin{figure}[h]
\centering

\includegraphics[width=150mm]{state_v2}

\caption{States now contains "cycle time" and "operation time" instead of "operation time" and "release time" because direct timespan manipulation was not utilized.}
\end{figure}

\subsection{Sensor calibration}
To mitigate different light conditions a sensor calibration stage had to be implemented. Before powering on the valve the top-hat sensor values are observed for three seconds. The trigger value is calculated by reducing the lowest value by 10\%.
\begin{figure}[h]
\begin{align*}
    tv &=min\{v_1, \dots, v_n\} * 0.1 && \text{Trigger value} \\
    v &= \text{Obtained sensor value}
\end{align*}
\caption{Formula used in the top-hat trigger value calibration stage.}
\end{figure}

\subsection{Self validation}
To validate if the corpus is properly detected by the top-hats the valve is opened until both sensors have observed the previously calculated trigger value. If a sensor doesn't trigger in a five second grace period, program execution is interrupted and correct behavior of the valve as well as the sensors has to be confirmed manually.

If self validation succeeds, the corpus is at the highest possible point on the table leg.

\subsection{Hovering}
Initially it was decided that the two infrared sensors should by utilized as boundaries for the hovering location because it was assumed that pressure inconsistencies would require an upper bound to prevent situations in which the thrust changes would cause the corpus to ascend too far. 
At the beginning of the hovering stage the thrust level would be adjusted to a level that would lead to a descend of the corpus. This descend should be slow enough for the corpus to spend enough time in front of the sensors to allow for thrust modifications.
These modifications would occur whenever the corpus trigged a top-hat. While the lower barrier was triggered the thrust would be increased and the opposite would happen for the upper bound. After the initial trigger of the upper infrared sensor it was assumed the corpus was in the designated hover area and the thrust would remained unchanged until further modifications were required.

During the implementation of this idea it became apparent that the precise thrust corrections happening at the lower sensor would never cause the corpus to rise above the upper barrier, thus rendering it ineffective. It was decided that the upper sensor would be ignored until a different use-case for it would arise. This change altered the procedure to simply decrease the thrust until the lower sensor was set off and to increase it while the top-hat was triggered.

To gradually modify the thrust by a set percentage per second, a time dependent variable was introduced into the calculation. 

\begin{figure}[h]
\begin{verbatim}
# Fixed cycle time
CYCLE_TIME = 50

# Percentage modified in 1 second
RATIO_MODIFIER = 0.02

# Start off at 60% thrust
operation_ratio = 0.6

while running:
    delta_time = end_time - start_time
    
    start_time = time()

    # If lower sensor triggered
    if lower_top_head > lower_lowest_value:
        operation_ratio -= (RATIO_MODIFIER * delta_time)
    else:
        operation_ratio += (RATIO_MODIFIER * delta_time)

    # Apply thrust modification
    push_state(CYCLE_TIME, operation_ratio)

    sleep(0.1)
    end_time = time()
\end{verbatim}
\caption{Pseudo code of gradual thrust modification.}
\end{figure}

Through testing revealed that pressure drops can occur. This can lead to a more rapid descend of the corpus than anticipated. If the corpus drops under the lower top-head, its position is still assumed to be above the sensor by the program and therefor the thrust is continuously lowered. In this state the rocket body can not be recovered autonomously. 

To combat this behavior it was decided to utilize the upper sensor, this time as the hover point, and the lower one as a recovery point. If the corpus is detected by the lower sensor the thrust is temporarily increased rapidly to raise the altitude of the body above the hovering point. 



\chapter{Hummingbird 9001}

\section{Concept}

% 2guides 2 dimentional tilting ability

% use of onboard sencors (accelerometer, gyrometer, ultrasound distance)

\begin{figure}[h]
\centering

\includegraphics[width=165mm]{sketch_xx_second_concept}

\caption{Concept}
\end{figure}

\subsection{Implementation}

